[gd_scene load_steps=11 format=2]

[sub_resource type="QuadMesh" id=1]

[sub_resource type="Shader" id=2]
code = "shader_type spatial;
render_mode blend_mix, unshaded;

uniform sampler2D iChannel0;

uniform float flameEdgeWidth = 0.1;
uniform float flameThinningFactor = 3.0;
uniform float flameRampCenter = 0.15;
uniform float flameBrightness = 2.25;

uniform vec2 center = vec2(0.5, 0.5);

uniform vec4 flameEdgeColor: hint_color = vec4(0, 0.8, 1, 1);
uniform vec4 flameRampColor1: hint_color = vec4(0.4, 0.4, 1, 1);
uniform vec4 flameRampColor2: hint_color = vec4(1, 0.25, 0.05, 1);
uniform vec4 flameRampColor3: hint_color = vec4(1, 1, 0.8, 1);
 
// Rekursions are not allowed so we need to have different names. Sucks.  
float circularVignette2(vec2 screenUV, vec2 offset, float scale)
{
    return 1.0 - (length(screenUV - offset - center) / 0.5) / scale;
}

float circularVignette1(vec2 screenUV) 
{ 
    return circularVignette2(screenUV, vec2(0, 0), 1.0); 
}

void fragment()
{
	float pi = 3.14;
	float flameNoiseScales1 = 9.25;
	float flameNoiseScales2 = 8.0;
	
	vec2 flameNoiseSpeeds1 = vec2(0.06, 0.27);
	vec2 flameNoiseSpeeds2 = vec2(0.03, 0.21);
	
	vec2 flameUV1 = UV / flameNoiseScales1 + TIME * flameNoiseSpeeds1;
    vec2 flameUV2 = UV / flameNoiseScales2 + TIME * flameNoiseSpeeds2 + center;
	
	float jitterTime = TIME * 0.2;
	float jitter = texture(iChannel0, vec2(jitterTime, 0)).r * 0.4; // +/- 0.5
	
	// flame motion
	float fade = (texture(iChannel0, flameUV1).r * texture(iChannel0, flameUV2).r) * 2.0;
	
	// adding some fill into the bottom of the flame before fading the edges
	fade = clamp(fade + UV.y * 0.8, 0.0, 1.0);
	
	// thin the flame on the lateral edges
	if (abs(UV.x - 0.5) > 0.5 / flameThinningFactor) {
		// no need to continue math outside the lateral edges
		ALPHA = 0.0;
		return;
	} else {
		fade *= cos((UV.x - 0.5) * pi * flameThinningFactor);
	}
	
	// create ovular shape of flame
    if (UV.y > 0.5) {
		fade *= circularVignette1(UV);   
    } else {
		fade *= 1.0 - abs(UV.x - center.x) / 0.5;
    }
	
	float rampCenter = flameRampCenter + jitter;
	
	vec4 flameColor;
	// 3-color ramp
	if (UV.y > 1.0 - rampCenter) { 
		flameColor = mix(flameRampColor1, flameRampColor2, (1.0 - UV.y) / rampCenter);
	} else {
		flameColor = mix(flameRampColor2, flameRampColor3, (1.0 - rampCenter - UV.y) / rampCenter);
	}
	
	// vertical flame death
	float clampVal = 1.0 - UV.y;
	
	if (fade < clampVal) {
		ALPHA = 0.0;
		return;
    } else if (fade < clampVal + flameEdgeWidth) {
		fade = (fade - clampVal) / flameEdgeWidth;
		flameColor = mix(flameEdgeColor, flameColor, fade);
    } else {
		fade = 1.0;
    }
	
	flameColor *= flameBrightness * fade;
	
	ALPHA = fade;
	ALBEDO = flameColor.rgb; // vec3(1.0, 0.0, 0.0);
}"

[sub_resource type="OpenSimplexNoise" id=3]
seed = 10
period = 16.0
persistence = 0.9
lacunarity = 2.4

[sub_resource type="NoiseTexture" id=4]
width = 256
height = 256
seamless = true
noise = SubResource( 3 )

[sub_resource type="ShaderMaterial" id=5]
shader = SubResource( 2 )
shader_param/flameEdgeWidth = 0.1
shader_param/flameThinningFactor = 3.0
shader_param/flameRampCenter = 0.15
shader_param/flameBrightness = 2.25
shader_param/center = Vector2( 0.5, 0.5 )
shader_param/flameEdgeColor = Color( 0, 0.8, 1, 1 )
shader_param/flameRampColor1 = Color( 0.4, 0.4, 1, 1 )
shader_param/flameRampColor2 = Color( 1, 0.25, 0.05, 1 )
shader_param/flameRampColor3 = Color( 1, 1, 0.8, 1 )
shader_param/iChannel0 = SubResource( 4 )

[sub_resource type="QuadMesh" id=6]

[sub_resource type="Shader" id=7]
code = "shader_type spatial;
render_mode blend_mix, unshaded;

uniform sampler2D noiseTexture: hint_albedo;
uniform vec4 flameColorInner: hint_color;
uniform vec4 flameColorOuter: hint_color;

float random(vec2 p, float seed)
{ 
    return fract(95.12*sin( (dot (vec2(p.x,p.y),vec2(3.654,6.987)+seed))));
}

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise(vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    // Four corners in 2D of a tile
    float a = random(i, 20.0);
    float b = random(i + vec2(1.0, 0.0), 24.0);
    float c = random(i + vec2(0.0, 1.0), 45.0);
    float d = random(i + vec2(1.0, 1.0), 12.0);

    // Smooth Interpolation

    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);
    // u = smoothstep(0.,1.,f);

    // Mix 4 coorners percentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec2 LocalPosInCell(vec2 CellIndex) 
{
    float x = random(CellIndex,1.);
    float y = random(CellIndex,1.);
    
    return vec2(x,y);
}

float CellAtGridIndex(vec2 pos,vec2 off,float minSize,float maxSize)
{
    vec2 GridIndex = floor(pos);
    vec2 LocalPos = fract(pos);
    float randSize = random(GridIndex-off,1.);
    randSize = mix(minSize,maxSize,randSize);
    
    vec2 SpherePos = LocalPosInCell( floor(GridIndex - off) );
    float Sphere = (randSize - length( (LocalPos+off-SpherePos) ));    
    return smoothstep(0.,1.,Sphere*0.5+0.5);
}

float Voronoi(vec2 uv,float Size,float cellMinSize,float cellMaxSize)
{
    uv *= Size * 1.;
    float SphereCenter = CellAtGridIndex(uv, vec2(0.,0.), cellMinSize, cellMaxSize );
    
    float SphereUp = CellAtGridIndex(uv , vec2(0.,1.), cellMinSize, cellMaxSize);
    float SphereDown = CellAtGridIndex(uv , vec2(0.,-1.), cellMinSize, cellMaxSize);
    float SphereLeft = CellAtGridIndex(uv , vec2(-1.,0.), cellMinSize, cellMaxSize);
    float SphereRight = CellAtGridIndex(uv , vec2(1.,0.), cellMinSize, cellMaxSize);
    
    float SphereUpRight = CellAtGridIndex(uv , vec2(1.,1.), cellMinSize, cellMaxSize);
    float SphereDownRight = CellAtGridIndex(uv , vec2(1.,-1.), cellMinSize, cellMaxSize);
    float SphereUpLeft = CellAtGridIndex(uv , vec2(-1.,1.), cellMinSize, cellMaxSize);
    float SphereDownLeft = CellAtGridIndex(uv , vec2(-1.,-1.), cellMinSize, cellMaxSize);
    
    float mixCells = max(SphereCenter,SphereUp);
    mixCells = max(mixCells,SphereDown);
    mixCells = max(mixCells,SphereLeft);
    mixCells = max(mixCells,SphereRight);
    
    mixCells = max(mixCells,SphereUpRight);
    mixCells = max(mixCells,SphereDownRight);
    mixCells = max(mixCells,SphereUpLeft);
    mixCells = max(mixCells,SphereDownLeft);
    
    return mixCells;
}

void fragment() {
	vec2 start = vec2(0.5, 1.0);
	vec3 flameColor = vec3(1.0, 0., 0.);
	
	// Flame Flicker
	vec2 uv1 = UV.xy;
	vec2 uv2 = UV.xy;
	uv1.y = uv1.y + TIME * 1.3;
	uv2.y = uv2.y + TIME * 1.3;
    float mixCellsSmall = 1. - Voronoi(uv2, 20., 0.3, 1.2);
	float mixCellsBig = 1. - Voronoi(uv1, 2., 0.9, 1.);
	float flameFlicker = mixCellsBig * mixCellsSmall;
	
	// General Shape
	vec2 noiseUV = UV;
	noiseUV.y = noiseUV.y + TIME * 0.8;
	float border = clamp(UV.y * 1.2, 0.0, 1.0) * clamp(UV.x * 4.0, 0.0, 1.0) * clamp((1.0 - UV.x) * 4.0, 0.0, 1.0);
	
	float flameShapeOuter = step(.15, texture(noiseTexture, noiseUV).r * border);
	float flameShapeInner = step(.2, texture(noiseTexture, noiseUV).r * border);
	
	// flameShape = flameShape * flameFlicker;

	float d = distance(start, UV);
	
	if(d < 0.3) {
		ALBEDO = flameColor;
		// ALPHA = result;
	} else {
		// ALPHA = 0.;
	}
	
	// ALPHA = x;
	// ALBEDO = flameColor * border;
	ALBEDO = flameShapeInner * flameColorInner.rgb + flameShapeOuter * flameColorOuter.rgb;
    // ALBEDO = vec3(result);
}"

[sub_resource type="OpenSimplexNoise" id=9]

[sub_resource type="NoiseTexture" id=10]
width = 256
height = 256
seamless = true
noise = SubResource( 9 )

[sub_resource type="ShaderMaterial" id=8]
shader = SubResource( 7 )
shader_param/flameColorInner = Color( 0.984314, 0.917647, 0.392157, 1 )
shader_param/flameColorOuter = Color( 0.945098, 0.133333, 0.133333, 1 )
shader_param/noiseTexture = SubResource( 10 )

[node name="Spatial" type="Spatial"]

[node name="MeshInstance" type="MeshInstance" parent="."]
transform = Transform( 1.00447, 0, 0, 0, 1.00447, 0, 0, 0, 1.00447, 0, 0.00436541, 0 )
mesh = SubResource( 1 )
material/0 = SubResource( 5 )

[node name="MeshInstance2" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0.87885, 0.00145179, 0 )
mesh = SubResource( 6 )
material/0 = SubResource( 8 )
