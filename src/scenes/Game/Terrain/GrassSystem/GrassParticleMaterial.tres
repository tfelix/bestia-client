[gd_resource type="ShaderMaterial" load_steps=4 format=2]

[sub_resource type="Shader" id=8]
code = "shader_type particles;

uniform float rows = 4;
uniform float spacing = 1.0;

uniform float minRenderDistance = 0.0;
uniform float maxRenderDistance = 20.0;
uniform vec3 cameraPosition = vec3(0.0);

// TODO Replace noisemap with function
uniform sampler2D noisemap;

float getHeight(vec2 pos) {
	// Find a clever way to position grass
	return 0.0;
}

void vertex() {	
	vec3 pos = vec3(0.0);
	pos.z = float(INDEX);
	pos.x = mod(pos.z, rows);
	pos.z = (pos.z - pos.x) / rows;
	
	// Center it
	pos.x -= rows * 0.5;
	pos.z -= rows * 0.5;
	
	// Apply spacing
	pos *= spacing;
	
	// center on our particle location but without our spacing
	pos.x += EMISSION_TRANSFORM[3][0] - mod(EMISSION_TRANSFORM[3][0], spacing);
	pos.z += EMISSION_TRANSFORM[3][2] - mod(EMISSION_TRANSFORM[3][2], spacing);
	
	// add placement noise based on world position
	vec3 noise = texture(noisemap, pos.xz).rgb;
	pos.x += noise.r * spacing;
	pos.z += noise.g * spacing;
	
	float dCam = distance(cameraPosition, pos);
	if(dCam > maxRenderDistance || dCam < minRenderDistance) {
		pos.y = - 10000.0;
	} else {
		pos.y = getHeight(pos.xz);
	}
	
	// just some random rotation
	TRANSFORM[0][0] = cos(noise.z * 3.0);
	TRANSFORM[0][2] = -sin(noise.z * 3.0);
	TRANSFORM[2][0] = sin(noise.z * 3.0);
	TRANSFORM[2][2] = cos(noise.z);
	
	TRANSFORM[3][0] = pos.x;
	TRANSFORM[3][1] = pos.y;
	TRANSFORM[3][2] = pos.z;
}"

[sub_resource type="OpenSimplexNoise" id=9]

[sub_resource type="NoiseTexture" id=10]
seamless = true
noise = SubResource( 9 )

[resource]
shader = SubResource( 8 )
shader_param/rows = 4.0
shader_param/spacing = 1.0
shader_param/minRenderDistance = 20.0
shader_param/maxRenderDistance = 100.0
shader_param/cameraPosition = Vector3( 0, 0, 0 )
shader_param/noisemap = SubResource( 10 )
