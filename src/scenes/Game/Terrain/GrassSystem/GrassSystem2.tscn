[gd_scene load_steps=17 format=2]

[ext_resource path="res://scenes/Game/Terrain/GrassSystem/GrassSystem.gd" type="Script" id=1]
[ext_resource path="res://scenes/Game/Terrain/GrassSystem/Grass_1.png" type="Texture" id=2]
[ext_resource path="res://scenes/Game/Terrain/GrassSystem/NearGrass.gd" type="Script" id=3]
[ext_resource path="res://scenes/Game/Terrain/GrassSystem/FarGrass.gd" type="Script" id=4]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode cull_disabled;

uniform vec4 grass_top : hint_color;
uniform vec4 grass_bottom: hint_color;

uniform vec3 playerPos;

uniform sampler2D grass_map: hint_albedo;

uniform float amplitude = 0.1;
uniform vec2 speed = vec2(2.0, 1.5);
uniform vec2 scale = vec2(0.1, 0.2);

uniform float rim: hint_range(0,1);
uniform float rim_tint : hint_range(0,1);

float random(vec2 coord){
	return fract(sin(dot(coord, vec2(12.9898, 78.233)))* 43758.5453123);
}

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise(vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);

    // Mix 4 coorners percentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

void vertex() {
	vec3 worldpos = (WORLD_MATRIX * vec4(VERTEX, 1.0)).xyz;
	
	// Perform object displacement
	float dis = distance(playerPos, worldpos);
	float radius = 2.0;
	float circle = 1.0 - clamp(dis / radius, 0.0, 1.0);
	
	// Wind Displacement will only happen if the grass is not flattened via walking over it
	// Use vertex color to pin grass to bottom
	VERTEX.x += COLOR.r * amplitude * sin(worldpos.x * scale.x * 0.75 + TIME * speed.x) * cos(worldpos.z * scale.x + TIME * speed.x * 0.25);
	VERTEX.z += COLOR.r * amplitude * sin(worldpos.x * scale.y + TIME * speed.y * 0.35) * cos(worldpos.z * scale.y * 0.80 + TIME * speed.y);
	NORMAL = vec3(0.0, 1.0, 0.0);
}

void fragment() {
	vec2 base_uv = UV;
	
	vec4 color = texture(grass_map, UV);
	
	ALBEDO = grass_bottom.rgb;
	ALPHA = color.a;
	ALPHA_SCISSOR=0.99;
}
"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/grass_top = Color( 0.811765, 0.945098, 0.168627, 1 )
shader_param/grass_bottom = Color( 0.309804, 0.447059, 0.0901961, 1 )
shader_param/playerPos = null
shader_param/amplitude = 0.1
shader_param/speed = Vector2( 2, 1.5 )
shader_param/scale = Vector2( 0.1, 0.2 )
shader_param/rim = 0.02
shader_param/rim_tint = 0.7
shader_param/grass_map = ExtResource( 2 )

[sub_resource type="Shader" id=3]
code = "shader_type particles;

uniform float rows = 4;
uniform float spacing = 1.0;

uniform float minRenderDistance = 0.0;
uniform float maxRenderDistance = 20.0;
uniform vec3 cameraPosition = vec3(0.0);

// TODO Replace noisemap with function
uniform sampler2D noisemap;

float getHeight(vec2 pos) {
	// Find a clever way to position grass
	return 0.0;
}

void vertex() {	
	vec3 pos = vec3(0.0);
	pos.z = float(INDEX);
	pos.x = mod(pos.z, rows);
	pos.z = (pos.z - pos.x) / rows;
	
	// Center it
	pos.x -= rows * 0.5;
	pos.z -= rows * 0.5;
	
	// Apply spacing
	pos *= spacing;
	
	// center on our particle location but without our spacing
	pos.x += EMISSION_TRANSFORM[3][0] - mod(EMISSION_TRANSFORM[3][0], spacing);
	pos.z += EMISSION_TRANSFORM[3][2] - mod(EMISSION_TRANSFORM[3][2], spacing);
	
	// add placement noise based on world position
	vec3 noise = texture(noisemap, pos.xz).rgb;
	pos.x += noise.r * spacing;
	pos.z += noise.g * spacing;
	
	float dCam = distance(cameraPosition, pos);
	if(dCam > maxRenderDistance || dCam < minRenderDistance) {
		pos.y = - 10000.0;
	} else {
		pos.y = getHeight(pos.xz);
	}
	
	// just some random rotation
	TRANSFORM[0][0] = cos(noise.z * 3.0);
	TRANSFORM[0][2] = -sin(noise.z * 3.0);
	TRANSFORM[2][0] = sin(noise.z * 3.0);
	TRANSFORM[2][2] = cos(noise.z);
	
	TRANSFORM[3][0] = pos.x;
	TRANSFORM[3][1] = pos.y;
	TRANSFORM[3][2] = pos.z;
}"

[sub_resource type="OpenSimplexNoise" id=4]

[sub_resource type="NoiseTexture" id=5]
seamless = true
noise = SubResource( 4 )

[sub_resource type="ShaderMaterial" id=6]
shader = SubResource( 3 )
shader_param/rows = 4.0
shader_param/spacing = 1.0
shader_param/minRenderDistance = 0.0
shader_param/maxRenderDistance = 12.0
shader_param/cameraPosition = Vector3( 0, 0, 0 )
shader_param/noisemap = SubResource( 5 )

[sub_resource type="QuadMesh" id=7]

[sub_resource type="ShaderMaterial" id=8]
shader = SubResource( 3 )
shader_param/rows = 4.0
shader_param/spacing = 1.0
shader_param/minRenderDistance = 12.0
shader_param/maxRenderDistance = 35.0
shader_param/cameraPosition = Vector3( 0, 0, 0 )
shader_param/noisemap = SubResource( 5 )

[sub_resource type="SpatialMaterial" id=9]
params_cull_mode = 2
albedo_color = Color( 0.733333, 0.101961, 0.101961, 1 )

[sub_resource type="QuadMesh" id=10]
material = SubResource( 9 )
size = Vector2( 0.5, 1 )

[sub_resource type="SphereMesh" id=11]
radius = 0.5
height = 1.0

[sub_resource type="SpatialMaterial" id=12]
flags_unshaded = true

[node name="GrassSystem" type="Spatial"]
script = ExtResource( 1 )

[node name="NearGrass" type="Particles" parent="."]
material_override = SubResource( 2 )
cast_shadow = 2
explosiveness = 1.0
local_coords = false
process_material = SubResource( 6 )
draw_pass_1 = SubResource( 7 )
script = ExtResource( 3 )
rows = 150
spacing = 0.18

[node name="MediumGrass" type="Particles" parent="."]
explosiveness = 1.0
local_coords = false
process_material = SubResource( 8 )
draw_pass_1 = SubResource( 10 )
script = ExtResource( 4 )
rows = 90
spacing = 0.8

[node name="FakeCam" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 3.18964, 0 )
mesh = SubResource( 11 )
material/0 = SubResource( 12 )
